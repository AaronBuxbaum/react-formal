{"componentChunkName":"component---node-modules-docpocalypse-gatsby-theme-src-templates-component-tsx","path":"/api/Field","result":{"data":{"docpocalypse":{"id":"cb939f12-c24c-5824-af5e-40d41c8f4903","type":"component","name":"Field","packageName":"react-formal","importName":"import Form from 'react-formal'","tags":[{"name":"alias","value":"Field"},{"name":"memberof","value":"Form"}],"example":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The Field Component renders a form control and handles input value updates and validations.\\nChanges to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Field>\"), \" value are automatically propagated back up to the containing Form\\nComponent.\"), mdx(\"h2\", {\n    \"id\": \"overview\"\n  }, \"Overview\"), mdx(\"p\", null, \"In the simplest cases \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Field>\"), \"s provide a light abstraction over normal input components. Fields\\nshouls provide a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" mapping the input to a branch of the central form data.\\nProviding values and onChange handlers is taken take care of, as well as basic\\nvalue coalescing for multiple selects and checkbox groups.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import Form from \\\"@docs/components/FormWithResult\\\";\\n\\n<Form\\n  defaultValue={{\\n    name: { first: \\\"Sally\\\" },\\n    colors: [\\\"red\\\"]\\n  }}\\n>\\n  <label>\\n    Name\\n    <Form.Field name=\\\"name.first\\\" placeholder=\\\"First name\\\" />\\n  </label>\\n  <label>\\n    Favorite Colors <small>(ctrl/cmd click to select multiple)</small>\\n    <Form.Field as=\\\"select\\\" multiple name=\\\"colors\\\">\\n      <option value=\\\"red\\\">Red</option>\\n      <option value=\\\"yellow\\\">Yellow</option>\\n      <option value=\\\"blue\\\">Blue</option>\\n      <option value=\\\"\\\">Other</option>\\n    </Form.Field>\\n  </label>\\n</Form>;\\n\")), mdx(\"p\", null, \"You can manually control the type and sort of input via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" prop (for textareas and selects),\\nand the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" prop for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inputs\"), \" same as with plain HTML inputs. Fields always\\nprovide \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" props to their inputs.\"), mdx(\"h2\", {\n    \"id\": \"checkbox-and-radios\"\n  }, \"Checkbox and Radios\"), mdx(\"p\", null, \"Create a unified set of checkbox/radio input's that map to a single form field\\nby using multiple \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Field>\"), \"s with the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import Form from \\\"@docs/components/FormWithResult\\\";\\n\\n<Form defaultValue={{ color: \\\"red\\\" }}>\\n  <fieldset>\\n    <legend>Favorite Color</legend>\\n    <label>\\n      <Form.Field type=\\\"radio\\\" name=\\\"color\\\" value=\\\"red\\\" /> Red\\n    </label>\\n    <label>\\n      <Form.Field type=\\\"radio\\\" name=\\\"color\\\" value=\\\"blue\\\" /> Blue\\n    </label>\\n    <label>\\n      <Form.Field type=\\\"radio\\\" name=\\\"color\\\" value=\\\"yellow\\\" /> Yellow\\n    </label>\\n    <label>\\n      <Form.Field type=\\\"radio\\\" name=\\\"color\\\" value=\\\"orange\\\" /> Orange\\n    </label>\\n  </fieldset>\\n</Form>;\\n\")), mdx(\"p\", null, \"Use groups of checkboxes to represent list values. React Formal will intelligently\\ninsert or remove items if the current field value is an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array\"), \" or, absent a\\nvalue, the schema for the field is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yup.array()\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import Form from \\\"@docs/components/FormWithResult\\\";\\n\\n<Form\\n  defaultValue={{\\n    colors: [\\\"red\\\"]\\n  }}\\n>\\n  <fieldset>\\n    <legend>Favorite Colors</legend>\\n    <label>\\n      <Form.Field type=\\\"checkbox\\\" name=\\\"colors\\\" value=\\\"red\\\" /> Red\\n    </label>\\n    <label>\\n      <Form.Field type=\\\"checkbox\\\" name=\\\"colors\\\" value=\\\"blue\\\" /> Blue\\n    </label>\\n    <label>\\n      <Form.Field type=\\\"checkbox\\\" name=\\\"colors\\\" value=\\\"yellow\\\" />{\\\" \\\"}\\n      Yellow\\n    </label>\\n    <label>\\n      <Form.Field type=\\\"checkbox\\\" name=\\\"colors\\\" value=\\\"orange\\\" />{\\\" \\\"}\\n      Orange\\n    </label>\\n  </fieldset>\\n</Form>;\\n\")), mdx(\"h2\", {\n    \"id\": \"custom-components\"\n  }, \"Custom components\"), mdx(\"p\", null, \"Fields are not limited to native input components. You can pass \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" component\\ntype to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \". The only required interface a component needs to respect is the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" pattern for controlled fields.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"previewClassName=reset\",\n    \"previewClassName\": \"reset\"\n  }), \"import Form from \\\"../components/FormWithResult\\\";\\n\\nimport DropdownList from \\\"react-widgets/lib/DropdownList\\\";\\n\\n<Form defaultValue={{ color: \\\"red\\\" }}>\\n  <label>\\n    Favorite Colors\\n    <Form.Field\\n      name=\\\"color\\\"\\n      as={DropdownList}\\n      data={[\\\"Red\\\", \\\"Yellow\\\", \\\"Blue\\\", \\\"Other\\\"]}\\n    />\\n  </label>\\n</Form>;\\n\")), mdx(\"p\", null, \"For a better typed experience with TypeScript, consider using the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#children\"\n  }), \"render prop API instead\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"import Form from \\\"../components/FormWithResult\\\";\\n\\nimport DropdownList from \\\"react-widgets/lib/DropdownList\\\";\\n\\n<Form defaultValue={{ color: \\\"red\\\" }}>\\n  <label>\\n    Favorite Colors\\n    <Form.Field name=\\\"color\\\">\\n      {props => (\\n        <DropdownList\\n          data={[\\\"Red\\\", \\\"Yellow\\\", \\\"Blue\\\", \\\"Other\\\"]}\\n          {...props}\\n        />\\n      )}\\n    </Form.Field>\\n  </label>\\n</Form>;\\n\")), mdx(\"p\", null, \"In addition to injecting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Field>\"), \" components with events and the field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \", a\\nspecial prop called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta\"), \" is also provided to all Field renderer components. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta\"), \"\\ncontains helpful context and methods for doing manual field operations.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"interface FieldMeta {\\n  value:    any;              // the Field Value\\n  valid:    boolean;          // Whether the field is currently valid\\n  invalid:  boolean;          // inverse of valid\\n  touched:  boolean:          // whether the field has been touched yet\\n  errors:   Errors;           // the errors for this field\\n  schema?:  YupSchema;        // the schema for this field\\n  context?: Record<string, any>; // a yup context object\\n\\n  nativeTagName: 'input' | 'select'; // The inferred native HTML element.\\n  nativeType: string; // The inferred HTML input type, only valid for 'input's\\n\\n  // onError allows manually _replacing_ errors for the Field `name`\\n  // any existing errors for this path will be removed first\\n  onError(errors: Errors): void\\n  // The same callback passed to field components\\n  // for updating (and validating) a field value\\n  onChange(nextFieldValue: any): void\\n\\n\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"validation\"\n  }, \"Validation\"), mdx(\"p\", null, \"Field validation is automatically enabled for Fields with cooresponding Form schema.\\nFields inject \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onBlur\"), \" handlers to fire a validation.\\nField validation is debounced (see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"'/api/Form#delay'\"\n  }), \"Form delay\"), \") to reduce unnecessary\\nchecks while the user is still engaging with the input. Validation can be\\ndisabled per field with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noValidate\"), \" prop.\"), mdx(\"h3\", {\n    \"id\": \"trigger-events\"\n  }, \"Trigger Events\"), mdx(\"p\", null, \"Validation trigger events can be finely controlled via the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#validateOn\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"validateOn\")), \" prop.\\nEvents control which handlers \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Field>\"), \" passes to the input it renders. Multiple triggers\\ncan be configured using an object configuration.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-tsx\"\n  }), \"import * as yup from \\\"yup\\\";\\nimport Form from \\\"react-formal\\\";\\n\\nconst schema = yup.object({\\n  name: yup\\n    .string()\\n    .required()\\n    .min(4)\\n});\\n\\n<>\\n  <Form schema={schema}>\\n    <label>\\n      Validates onBlur\\n      <Form.Field name=\\\"name\\\" validateOn=\\\"blur\\\" />\\n    </label>\\n    <Form.Message for=\\\"name\\\" className=\\\"error\\\" />\\n  </Form>\\n  <Form schema={schema}>\\n    <label>\\n      Validates onBlur and onChange\\n      <Form.Field\\n        name=\\\"name\\\"\\n        validateOn={{ change: true, blur: true }}\\n      />\\n    </label>\\n    <Form.Message for=\\\"name\\\" className=\\\"error\\\" />\\n  </Form>\\n</>;\\n\")), mdx(\"p\", null, \"For more complex situations \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validateOn\"), \" accepts a function that is based the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta\"), \" for the field\\nand can conditionally return events based on context.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-tsx\"\n  }), \"import * as yup from \\\"yup\\\";\\nimport Form from \\\"react-formal\\\";\\n\\nconst schema = yup.object({\\n  email: yup\\n    .string()\\n    .email(\\\"Emails must contain an @ and a domain\\\")\\n    .required(\\\"Required\\\")\\n});\\n\\n// Only run validation onChange when the form is invalid\\nconst onBlurThenChangeAndBlur = meta => ({\\n  change: !meta.valid,\\n  blur: true\\n});\\n\\n<Form schema={schema}>\\n  <label>\\n    Enter an Email\\n    <Form.Field name=\\\"email\\\" validateOn={onBlurThenChangeAndBlur} />\\n  </label>\\n  <Form.Message for=\\\"email\\\" className=\\\"error\\\" />\\n</Form>;\\n\")), mdx(\"h3\", {\n    \"id\": \"preset-strategies\"\n  }, \"Preset Strategies\"), mdx(\"p\", null, \"As a convenience React Formal exports a few common trigger configurations\\nyou can mix and match if that is helpful.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"import { ValidateStrategies } from \\\"react-formal\\\";\\n\\nconst {\\n  Change,\\n  Blur,\\n  ChangeAndBlur,\\n  BlurThenChangeAndBlur\\n} = ValidateStrategies;\\n\\n<Form schema={schema}>\\n  <label>\\n    Email\\n    <Form.Field name=\\\"email\\\" validateOn={Blur} />\\n  </label>\\n  <Form.Message for=\\\"email\\\" className=\\\"error\\\" />\\n</Form>;\\n\")), mdx(\"p\", null, \"There is nothing special about these strategies, and you can roll your own easily.\\nThese are provied as a small convenience.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":""}},"composes":[],"props":[{"name":"name","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The Field name, which should be path corresponding to a specific form \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" path.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"// given the form value\\nvalue = {\\n  name: { first: '' }\\n  languages: ['english', 'spanish']\\n}\\n\\n// the path \\\"name.first\\\" would update the \\\"first\\\" property of the form value\\n<Form.Field name='name.first' />\\n\\n// use indexes for paths that cross arrays\\n<Form.Field name='languages[0]' />\\n\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>The Field name, which should be path corresponding to a specific form <code>value</code> path.</p>\n<pre><code class=\"language-jsx\" data-meta=\"static\">// given the form value\nvalue = {\n  name: { first: '' }\n  languages: ['english', 'spanish']\n}\n\n// the path \"name.first\" would update the \"first\" property of the form value\n&#x3C;Form.Field name='name.first' />\n\n// use indexes for paths that cross arrays\n&#x3C;Form.Field name='languages[0]' />\n</code></pre>"}},"required":true,"tsType":{"name":"union","raw":"string | string","elements":[{"name":"string"},{"name":"string"}]},"type":{"name":"string","value":null,"raw":null}},{"name":"as","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The Component Input the form should render. You can sepcify a native element such as 'input' or 'select'\\nor provide a Component type class directly. When no type is provided the Field will attempt determine\\nthe correct input from the Field's schema. A Field corresponding to a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yup.number()\"), \"\\nwill render a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type='number'\"), \" etc.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import Form from 'react-formal';\\n\\nfunction MyDateInput({ meta: _, ...props }) {\\n  return <input {...props} type='datetime-local' />\\n}\\n\\n<Form>\\n  Provide a type directly\\n  <Form.Field\\n    name='dateOfBirth'\\n    type='time'\\n    placeholder='time only'\\n  />\\n\\n  Use a custom Component\\n  (need native 'datetime' support to see it)\\n  <Form.Field\\n    name='dateOfBirth'\\n    as={MyDateInput}\\n  />\\n\\n</Form>\\n\")), mdx(\"p\", null, \"Custom Inputs should comply with the basic input api contract: set a value via a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" prop and\\nbroadcast changes to that value via an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" handler.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>The Component Input the form should render. You can sepcify a native element such as 'input' or 'select'\nor provide a Component type class directly. When no type is provided the Field will attempt determine\nthe correct input from the Field's schema. A Field corresponding to a <code>yup.number()</code>\nwill render a <code>type='number'</code> etc.</p>\n<pre><code class=\"language-jsx\">import Form from 'react-formal';\n\nfunction MyDateInput({ meta: _, ...props }) {\n  return &#x3C;input {...props} type='datetime-local' />\n}\n\n&#x3C;Form>\n  Provide a type directly\n  &#x3C;Form.Field\n    name='dateOfBirth'\n    type='time'\n    placeholder='time only'\n  />\n\n  Use a custom Component\n  (need native 'datetime' support to see it)\n  &#x3C;Form.Field\n    name='dateOfBirth'\n    as={MyDateInput}\n  />\n\n&#x3C;/Form>\n</code></pre>\n<p>Custom Inputs should comply with the basic input api contract: set a value via a <code>value</code> prop and\nbroadcast changes to that value via an <code>onChange</code> handler.</p>"}},"required":false,"tsType":{"name":"TAs"},"type":{"name":"union","value":[{"name":"elementType"},{"name":"string"}],"raw":null}},{"name":"validateOn","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Configure whether validation occur: onChange, onBlur, or both\\nYou can also specify a function that receives the Field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta\"), \" object and returns a configuration map\\nin order to change validation strategies based on validity or other metadata.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>Configure whether validation occur: onChange, onBlur, or both\nYou can also specify a function that receives the Field <code>meta</code> object and returns a configuration map\nin order to change validation strategies based on validity or other metadata.</p>"}},"required":false,"tsType":{"name":"ValidateOnConfig"},"type":{"name":"union","value":[{"name":"shape","value":{"change":{"name":"bool","required":false},"blur":{"name":"bool","required":false}}},{"name":"enum","value":[{"value":"'change'","computed":false},{"value":"'blur'","computed":false}]},{"name":"func"}],"raw":null}},{"name":"mapFromValue","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Customize how the Field value maps to the overall Form \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \".\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mapFromValue\"), \" can be a a string property name or a function that returns a\\nvalue for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \"'d path, allowing you to set commuted values from the Field.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"<Form.Field\\n  name='name'\\n  mapFromValue={fieldValue => `${fieldValue.first} ${fieldValue.last}`}\\n/>\\n\")), mdx(\"p\", null, \"You can also provide an object hash, mapping paths of the Form \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \"\\nto fields in the field value using a string field name, or a function accessor.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import Form from '@docs/components/FormWithResult';\\nimport * as yup from 'yup';\\n\\nconst getYear = () => (new Date()).getFullYear()\\n\\nconst schema = yup.object({\\n  dateOfBirth: yup.date().required('Required'),\\n  age: yup.number()\\n});\\n\\n<Form\\n  schema={schema}\\n  defaultValue={schema.default()}\\n>\\n  <label>\\n    Date of Birth\\n    <Form.Field\\n      name='dateOfBirth'\\n      mapFromValue={{\\n        'dateOfBirth': event => event.target.value,\\n        'age': ({ target }) => target.valueAsDate ?\\n           getYear() - target.valueAsDate.getFullYear() : null\\n     }}/>\\n  </label>\\n  <label>\\n    Age\\n    <Form.Field name='age' />\\n  </label>\\n\\n  <Form.Submit type='submit'>Submit</Form.Submit>\\n</Form>\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>Customize how the Field value maps to the overall Form <code>value</code>.\n<code>mapFromValue</code> can be a a string property name or a function that returns a\nvalue for <code>name</code>'d path, allowing you to set commuted values from the Field.</p>\n<pre><code class=\"language-jsx\" data-meta=\"static\">&#x3C;Form.Field\n  name='name'\n  mapFromValue={fieldValue => `${fieldValue.first} ${fieldValue.last}`}\n/>\n</code></pre>\n<p>You can also provide an object hash, mapping paths of the Form <code>value</code>\nto fields in the field value using a string field name, or a function accessor.</p>\n<pre><code class=\"language-jsx\">import Form from '@docs/components/FormWithResult';\nimport * as yup from 'yup';\n\nconst getYear = () => (new Date()).getFullYear()\n\nconst schema = yup.object({\n  dateOfBirth: yup.date().required('Required'),\n  age: yup.number()\n});\n\n&#x3C;Form\n  schema={schema}\n  defaultValue={schema.default()}\n>\n  &#x3C;label>\n    Date of Birth\n    &#x3C;Form.Field\n      name='dateOfBirth'\n      mapFromValue={{\n        'dateOfBirth': event => event.target.value,\n        'age': ({ target }) => target.valueAsDate ?\n           getYear() - target.valueAsDate.getFullYear() : null\n     }}/>\n  &#x3C;/label>\n  &#x3C;label>\n    Age\n    &#x3C;Form.Field name='age' />\n  &#x3C;/label>\n\n  &#x3C;Form.Submit type='submit'>Submit&#x3C;/Form.Submit>\n&#x3C;/Form>\n</code></pre>"}},"required":false,"tsType":{"name":"MapFromValue"},"type":{"name":"union","value":[{"name":"func"},{"name":"string"},{"name":"object"}],"raw":null}},{"name":"mapToValue","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Map the Form value to the Field value. By default\\nthe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" of the Field is used to extract the relevant\\nproperty from the Form value.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"<Form.Field\\n  name='location'\\n  type=\\\"dropdownlist\\\"\\n  mapToValue={model=> pick(model, 'location', 'locationId')}\\n/>\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>Map the Form value to the Field value. By default\nthe <code>name</code> of the Field is used to extract the relevant\nproperty from the Form value.</p>\n<pre><code class=\"language-jsx\" data-meta=\"static\">&#x3C;Form.Field\n  name='location'\n  type=\"dropdownlist\"\n  mapToValue={model=> pick(model, 'location', 'locationId')}\n/>\n</code></pre>"}},"required":false,"tsType":{"name":"MapToValue"},"type":{"name":"func","value":null,"raw":null}},{"name":"errorClass","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The css class added to the Field Input when it fails validation\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>The css class added to the Field Input when it fails validation</p>"}},"required":false,"tsType":{"name":"string"},"type":{"name":"string","value":null,"raw":null}},{"name":"validates","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Tells the Field to trigger validation for specific paths.\\nUseful when used in conjuction with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mapFromValue\"), \" hash that updates more than one value, or\\nif you want to trigger validation for the parent path as well.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"NOTE! This overrides the default behavior of validating the field itself by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \",\\ninclude the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" if you want the field to validate itself.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"<Form.Field name='name.first' validates=\\\"name.last\\\" />\\n<Form.Field name='name' validates={['name', 'surname']} />\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>Tells the Field to trigger validation for specific paths.\nUseful when used in conjuction with a <code>mapFromValue</code> hash that updates more than one value, or\nif you want to trigger validation for the parent path as well.</p>\n<blockquote>\n<p>NOTE! This overrides the default behavior of validating the field itself by <code>name</code>,\ninclude the <code>name</code> if you want the field to validate itself.</p>\n</blockquote>\n<pre><code class=\"language-jsx\" data-meta=\"static\">&#x3C;Form.Field name='name.first' validates=\"name.last\" />\n&#x3C;Form.Field name='name' validates={['name', 'surname']} />\n</code></pre>"}},"required":false,"tsType":{"name":"union","raw":"string | string[]","elements":[{"name":"string"},{"name":"Array","elements":[{"name":"string"}],"raw":"string[]"}]},"type":{"name":"union","value":[{"name":"string"},{"name":"arrayOf","value":{"name":"string"}}],"raw":null}},{"name":"exclusive","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Indicates whether child paths of the current Field\\naffect the active state of the field.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"'names'\\n  - 'first'\\n  - 'last'\\n\")), mdx(\"p\", null, \"Are all considered \\\"part\\\" of a field named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'names'\"), \" by default. Does not\\naffect which paths are validated, only whether \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta.valid\"), \" considers child\\npaths for its state.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>Indicates whether child paths of the current Field\naffect the active state of the field.</p>\n<pre><code>'names'\n  - 'first'\n  - 'last'\n</code></pre>\n<p>Are all considered \"part\" of a field named <code>'names'</code> by default. Does not\naffect which paths are validated, only whether <code>meta.valid</code> considers child\npaths for its state.</p>"}},"required":false,"tsType":{"name":"boolean"},"type":{"name":"bool","value":null,"raw":null}},{"name":"noValidate","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Disables validation for the Field.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>Disables validation for the Field.</p>"}},"required":false,"tsType":{"name":"boolean"},"type":{"name":"bool","value":null,"raw":null}},{"name":"children","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When children is the traditional react element or nodes, they are\\npassed through as-is to the Field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" component.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"<Field type='select'>\\n  <option>red</option>\\n  <option>red</option>\\n</Field>\\n\")), mdx(\"p\", null, \"When \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" is a function, its called with the processed field\\nprops and field meta.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Tip:\"), \" you can pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onBlur\"), \" handlers\\nto the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Field>\"), \" component and it will handle merging them with its own injected\\nhandlers.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"static\",\n    \"static\": true\n  }), \"<Field name='birthDate'>\\n {(props, meta) =>\\n   <DataProvider>\\n     <Input {...props} />\\n   </DataProvider>\\n }\\n</Field>\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>When children is the traditional react element or nodes, they are\npassed through as-is to the Field <code>type</code> component.</p>\n<pre><code class=\"language-jsx\" data-meta=\"static\">&#x3C;Field type='select'>\n  &#x3C;option>red&#x3C;/option>\n  &#x3C;option>red&#x3C;/option>\n&#x3C;/Field>\n</code></pre>\n<p>When <code>children</code> is a function, its called with the processed field\nprops and field meta.</p>\n<p><strong>Tip:</strong> you can pass <code>onChange</code> and <code>onBlur</code> handlers\nto the <code>&#x3C;Field></code> component and it will handle merging them with its own injected\nhandlers.</p>\n<pre><code class=\"language-jsx\" data-meta=\"static\">&#x3C;Field name='birthDate'>\n {(props, meta) =>\n   &#x3C;DataProvider>\n     &#x3C;Input {...props} />\n   &#x3C;/DataProvider>\n }\n&#x3C;/Field>\n</code></pre>"}},"required":false,"tsType":{"name":"union","raw":"React.ReactNode\n| ((fieldProps: FieldRenderProps, meta: FieldMeta) => React.ReactNode)","elements":[{"name":"ReactReactNode","raw":"React.ReactNode"},{"name":"unknown"}]},"type":{"name":"union","value":[{"name":"node"},{"name":"func"}],"raw":null}},{"name":"injectMeta","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Instruct the field to not inject the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta\"), \" prop into the input,\\ndefaults to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" is a non DOM component\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>Instruct the field to not inject the <code>meta</code> prop into the input,\ndefaults to <code>true</code> when <code>as</code> is a non DOM component</p>"}},"required":false,"tsType":{"name":"boolean"},"type":{"name":"bool","value":null,"raw":null}},{"name":"value","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A value to pass to checkboxs/radios/boolean inputs\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>A value to pass to checkboxs/radios/boolean inputs</p>"}},"required":false,"tsType":{"name":"any"},"type":{"name":"any","value":null,"raw":null}},{"name":"className","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":""}},"required":false,"tsType":{"name":"string"},"type":{"name":"string","value":null,"raw":null}},{"name":"type","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"An HTML input type attribute\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>An HTML input type attribute</p>"}},"required":false,"tsType":{"name":"string"},"type":{"name":"string","value":null,"raw":null}},{"name":"onChange","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A local onChange handler, will be merged with the injected onChange\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>A local onChange handler, will be merged with the injected onChange</p>"}},"required":false,"tsType":{"name":"signature","type":"function","raw":"(...args: any[]) => any","signature":{"arguments":[{"name":"args","type":{"name":"Array","elements":[{"name":"any"}],"raw":"any[]"},"rest":true}],"return":{"name":"any"}}},"type":{"name":"(...args: any[]) => any","value":null,"raw":null}},{"name":"onBlur","tags":[],"defaultValue":null,"description":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A local onBlur handler, will be merged with the injected onBlur\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"html":"<p>A local onBlur handler, will be merged with the injected onBlur</p>"}},"required":false,"tsType":{"name":"signature","type":"function","raw":"(...args: any[]) => any","signature":{"arguments":[{"name":"args","type":{"name":"Array","elements":[{"name":"any"}],"raw":"any[]"},"rest":true}],"return":{"name":"any"}}},"type":{"name":"(...args: any[]) => any","value":null,"raw":null}}]}},"pageContext":{"nodeId":"cb939f12-c24c-5824-af5e-40d41c8f4903","exampleId":"ee4266c0-1af4-5c5f-aa8d-df323105a5a0"}}}