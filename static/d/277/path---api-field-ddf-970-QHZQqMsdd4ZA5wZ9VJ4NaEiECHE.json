{"data":{"mdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `A specialized `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `Form.Field`), ` component that handles array fields.\nSpecifically it handles errors correctly when items are added, removed, or\nreordered.`));\n});"}},"metadata":{"displayName":"Field","doclets":{},"composes":null,"parent":{"__typename":"File","sourceInstanceName":"source"},"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `The Field Component renders a form control and handles input value updates and validations.\nChanges to the Field value are automatically propagated back up to the containing Form\nComponent.`), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Fields provide a light abstraction over normal input components where values and onChange handlers\nare take care of for you. Beyond that they just render the input for their type, Fields whille pass along\nany props and children to the input so you can easily configure new input types.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-jsx\",\n      \"metaString\": \"{ \\\"editable\\\": true }\",\n      \"{\": true,\n      \"\\\"editable\\\":\": true,\n      \"true\": true,\n      \"}\": true\n    }\n  }, `<Form\n  noValidate\n  schema={modelSchema}\n  defaultValue={{\n    name: { first: 'Sally'},\n    colorID: 0\n  }}\n>\n    <label htmlFor=\"example-firstName\">Name</label>\n    <Form.Field\n      name='name.first'\n      placeholder='First name'\n      id=\"example-firstName\"\n    />\n    <label htmlFor=\"example-color\">Favorite Color</label>\n    <Form.Field\n      as='select'\n      name='colorId'\n      id=\"example-color\"\n    >\n      <option value={0}>Red</option>\n      <option value={1}>Yellow</option>\n      <option value={2}>Blue</option>\n      <option value={3}>other</option>\n    </Form.Field>\n  <Form.Submit type='submit'>Submit</Form.Submit>\n</Form>\n`)), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `In addition to injecting Field components with events and the field `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `value`), `, a\nspecial prop called `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `meta`), ` is also provided to all Field renderer components. `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `meta`), `\ncontains a bunch of helpful context as well some methods for doing advanced field operations.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-ts\",\n      \"metaString\": \"\"\n    }\n  }, `interface Meta {\n  value: any;\n  valid: boolean;\n  invalid: boolean;\n  errors: ErrorObjectMap;\n  touched: TouchedObjectMap\n  schema: YupSchema;\n  context: YupSchemaContext;\n}\n`)));\n});"}}},"props":[{"name":"name","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `The Field name, which should be path corresponding to a specific form `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `value`), ` path.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-js\",\n      \"metaString\": \"\"\n    }\n  }, `// given the form value\nvalue = {\n  name: { first: '' }\n  languages: ['english', 'spanish']\n}\n\n// the path \"name.first\" would update the \"first\" property of the form value\n<Form.Field name='name.first' />\n\n// use indexes for paths that cross arrays\n<Form.Field name='languages[0]' />\n`)));\n});"}}},"required":true,"type":{"name":"string","value":null,"raw":null}},{"name":"as","doclets":{},"defaultValue":{"value":"'input'","computed":false},"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `The Component Input the form should render. You can sepcify a native element such as 'textbox' or 'select'\nor provide a Component type class directly. When no type is provided the Field will attempt determine\nthe correct input from the Field's schema. A Field corresponding to a `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `yup.number()`), `\nwill render a `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `type='number'`), ` input by default.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-jsx\",\n      \"metaString\": \"{ \\\"editable\\\": true }\",\n      \"{\": true,\n      \"\\\"editable\\\":\": true,\n      \"true\": true,\n      \"}\": true\n    }\n  }, `<Form noValidate schema={modelSchema}>\n  Use the schema to determine type\n  <Form.Field\n    name='dateOfBirth'\n    placeholder='date'\n  />\n\n  Override it!\n  <Form.Field\n    name='dateOfBirth'\n    type='time'\n    placeholder='time only'\n  />\n\n  Use a custom Component\n  (need native 'datetime' support to see it)\n  <Form.Field\n    name='dateOfBirth'\n    as={MyDateInput}/>\n\n</Form>\n`)), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Custom Inputs should comply with the basic input api contract: set a value via a `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `value`), ` prop and\nbroadcast changes to that value via an `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `onChange`), ` handler.`));\n});"}}},"required":false,"type":{"name":"union","value":[{"name":"custom","raw":"elementType"},{"name":"string"}],"raw":null}},{"name":"events","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Event name or array of event names that the Field should trigger a validation.\nYou can also specify a function that receives the Field `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `meta`), ` object and returns an array of events\nin order to change validation strategies based on validity.`));\n});"}}},"required":false,"type":{"name":"union","value":[{"name":"string"},{"name":"arrayOf","value":{"name":"string"}},{"name":"func"}],"raw":null}},{"name":"mapFromValue","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Customize how the Field value maps to the overall Form `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `value`), `.\n`, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `mapFromValue`), ` can be a a string property name or a function that returns a\nvalue for `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `name`), `'d path, allowing you to set commuted values from the Field.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-js\",\n      \"metaString\": \"\"\n    }\n  }, `<Form.Field\n  name='name'\n  mapFromValue={fieldValue => fieldValue.first + ' ' + fieldValue.last}\n/>\n`)), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `You can also provide an object hash, mapping paths of the Form `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `value`), `\nto fields in the field value using a string field name, or a function accessor.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-js\",\n      \"metaString\": \"{ \\\"editable\\\": true }\",\n      \"{\": true,\n      \"\\\"editable\\\":\": true,\n      \"true\": true,\n      \"}\": true\n    }\n  }, `<Form\n  schema={modelSchema}\n  defaultValue={modelSchema.default()}\n>\n  <label htmlFor=\"ex-mapToValue-firstName\">Name</label>\n  <Form.Field\n    name='name.first'\n    placeholder='First name'\n    id=\"ex-mapToValue-firstName\"\n  />\n\n  <label htmlFor=\"ex-mapToValue-dob\">Date of Birth</label>\n  <Form.Field\n    name='dateOfBirth'\n    id=\"ex-mapToValue-dob\"\n    mapFromValue={{\n      'dateOfBirth': date => date,\n      'age': date =>\n        (new Date()).getFullYear() - date.getFullYear()\n  }}/>\n\n  <label htmlFor=\"ex-mapToValue-age\">Age</label>\n  <Form.Field name='age' id=\"ex-mapToValue-age\"/>\n\n  <Form.Submit type='submit'>Submit</Form.Submit>\n</Form>\n`)));\n});"}}},"required":false,"type":{"name":"union","value":[{"name":"func"},{"name":"string"},{"name":"object"}],"raw":null}},{"name":"mapToValue","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Map the Form value to the Field value. By default\nthe `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `name`), ` of the Field is used to extract the relevant\nproperty from the Form value.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-js\",\n      \"metaString\": \"\"\n    }\n  }, `<Form.Field\n  name='location'\n  type=\"dropdownlist\"\n  mapToValue={model=> pick(model, 'location', 'locationId')}\n/>\n`)));\n});"}}},"required":false,"type":{"name":"func","value":null,"raw":null}},{"name":"errorClass","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `The css class added to the Field Input when it fails validation`));\n});"}}},"required":false,"type":{"name":"string","value":null,"raw":null}},{"name":"validates","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Tells the Field to trigger validation for specific paths.\nUseful when used in conjuction with a `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `mapFromValue`), ` hash that updates more than one value, or\nif you want to trigger validation for the parent path as well.`), React.createElement(MDXTag, {\n    name: \"blockquote\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components,\n    parentName: \"blockquote\"\n  }, `NOTE! This overrides the default behavior of validating the field itself by `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `name`), `,\ninclude the `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `name`), ` if you want the field to validate itself.`)), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-jsx\",\n      \"metaString\": \"\"\n    }\n  }, `<Form.Field name='name.first' validates=\"name.last\" />\n<Form.Field name='name' validates={['name', 'surname']} />\n`)));\n});"}}},"required":false,"type":{"name":"union","value":[{"name":"string"},{"name":"arrayOf","value":{"name":"string"}}],"raw":null}},{"name":"exclusive","doclets":{},"defaultValue":{"value":"false","computed":false},"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Indicates whether child fields of the named field\naffect the active state ofthe field.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-js\",\n      \"metaString\": \"\"\n    }\n  }, `-> 'names'\n-> 'names.first'\n-> 'names.last'\n`)), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Are all considered \"part\" of a field named `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `'names'`), ` by default.`));\n});"}}},"required":false,"type":{"name":"bool","value":null,"raw":null}},{"name":"noValidate","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Disables validation for the Field.`));\n});"}}},"required":false,"type":{"name":"bool","value":null,"raw":null}},{"name":"children","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `When children is the traditional react element or nodes, they are\npassed through as-is to the Field `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `type`), ` component.`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-jsx\",\n      \"metaString\": \"\"\n    }\n  }, `<Field type='select'>\n  <option>red</option>\n  <option>red</option>\n</Field>\n`)), React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `When `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `children`), ` is a function, its called with the processed field\nprops and the resolved Field Input component, for more advanced use cases`), React.createElement(MDXTag, {\n    name: \"pre\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"code\",\n    components: components,\n    parentName: \"pre\",\n    props: {\n      \"className\": \"language-jsx\",\n      \"metaString\": \"\"\n    }\n  }, `<Field name='birthDate'>\n {(props, Input) =>\n   <DataProvider>\n     <Input {...props} />\n   </DataProvider>\n }\n</Field>\n`)));\n});"}}},"required":false,"type":{"name":"union","value":[{"name":"node"},{"name":"func"}],"raw":null}},{"name":"noMeta","doclets":{},"defaultValue":null,"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Instruct the field to not inject the `, React.createElement(MDXTag, {\n    name: \"inlineCode\",\n    components: components,\n    parentName: \"p\"\n  }, `meta`), ` prop into the input`));\n});"}}},"required":false,"type":{"name":"bool","value":null,"raw":null}},{"name":"fieldRef","doclets":{},"defaultValue":{"value":"null","computed":false},"description":{"childMdx":{"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn ((_ref) => {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return React.createElement(MDXTag, {\n    name: \"wrapper\",\n    components: components\n  }, React.createElement(MDXTag, {\n    name: \"p\",\n    components: components\n  }, `Attach a ref to the rendered input component`));\n});"}}},"required":false,"type":{"name":"func","value":null,"raw":null}},{"name":"noResolveType","doclets":{"private":true},"defaultValue":null,"description":null,"required":false,"type":{"name":"bool","value":null,"raw":null}},{"name":"bindingProps","doclets":{"private":true},"defaultValue":null,"description":null,"required":false,"type":{"name":"object","value":null,"raw":null}},{"name":"yupContext","doclets":{"private":true},"defaultValue":null,"description":null,"required":false,"type":{"name":"any","value":null,"raw":null}},{"name":"errors","doclets":{"private":true},"defaultValue":null,"description":null,"required":false,"type":{"name":"object","value":null,"raw":null}},{"name":"touched","doclets":{"private":true},"defaultValue":null,"description":null,"required":false,"type":{"name":"bool","value":null,"raw":null}},{"name":"actions","doclets":{"private":true},"defaultValue":null,"description":null,"required":false,"type":{"name":"object","value":null,"raw":null}},{"name":"submits","doclets":{"private":true},"defaultValue":null,"description":null,"required":false,"type":{"name":"shape","value":{"submitAttempts":{"name":"number","required":false},"submitCount":{"name":"number","required":false},"submitting":{"name":"bool","required":false}},"raw":null}}]}},"pageContext":{"displayName":"Field"}}